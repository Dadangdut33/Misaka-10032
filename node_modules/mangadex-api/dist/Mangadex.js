"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Mangadex = void 0;
const Agent_1 = require("./Agent");
const chapter_1 = require("./api/chapter");
const group_1 = require("./api/group");
const manga_1 = require("./api/manga");
const tag_1 = require("./api/tag");
const user_1 = require("./api/user");
const Composer_1 = require("./Composer");
const deepmerge_1 = require("./lib/deepmerge");
const get_query_1 = require("./lib/get-query");
const get_search_headers_1 = require("./lib/get-search-headers");
const options_1 = require("./lib/options");
const Scraper_1 = require("./Scraper");
class Mangadex {
    constructor(options = {}) {
        this.options = Object.assign({}, options_1.DefaultOptions, options);
        this.agent = new Agent_1.Agent(this.options);
        const apiBaseOptions = {
            agent: this.agent,
            options: this.options
        };
        this.chapter = new chapter_1.ChapterResolver(apiBaseOptions);
        this.group = new group_1.GroupResolver(apiBaseOptions);
        this.manga = new manga_1.MangaResolver(apiBaseOptions);
        this.tag = new tag_1.TagResolver(apiBaseOptions);
        this.user = new user_1.UserResolver(apiBaseOptions);
    }
    /**
     * Search manga on mangadex
     * @param query Search query
     * @param options Request options
     */
    async search(query, options = {}) {
        const userQuery = get_query_1.getQuery(query);
        const headers = get_search_headers_1.getSearchHeaders(query, this.agent.getCookie());
        const result = await this.agent.call('search', deepmerge_1.deepmerge(options, {
            params: userQuery,
            headers
        }));
        return Scraper_1.Scraper.parseSearch(result, this.options.host);
    }
    /**
     * Search manga on mangadex
     * @param query Search query
     * @param options Request options
     */
    static async search(query, options = {}) {
        const userQuery = get_query_1.getQuery(query);
        const result = await Agent_1.Agent.call('search', deepmerge_1.deepmerge(options, {
            params: userQuery
        }));
        return Scraper_1.Scraper.parseSearch(result.data, options.baseUrl);
    }
    /**
     * Quick search manga on mangadex
     * @param query Search query
     * @param options Request options
     */
    async quickSearch(title, options = {}) {
        const result = await this.agent.call(`quick_search/${encodeURIComponent(title)}`, options);
        return Scraper_1.Scraper.parseSearch(result);
    }
    /**
     * Quick search manga on mangadex
     * @param query Search query
     * @param options Request options
     */
    static async quickSearch(title, options = {}) {
        const result = await Agent_1.Agent.call(`quick_search/${encodeURIComponent(title)}`, options);
        return Scraper_1.Scraper.parseSearch(result.data);
    }
    /**
     * Get home page of mangadex
     * @param options Request options
     */
    async getHome(options = {}) {
        const result = await this.agent.call('', options);
        return Scraper_1.Scraper.parseHome(result, this.options.host);
    }
    /**
     * Get home page of mangadex
     * @param options Request options
     */
    static async getHome(options = {}) {
        const result = await Agent_1.Agent.call('', options);
        return Scraper_1.Scraper.parseHome(result.data, options.baseUrl || options_1.DefaultOptions.host);
    }
    async friendAdd(userId, options = {}) {
        await this.agent.callAjaxAction({
            function: 'friend_add',
            id: userId
        }, options);
        return true;
    }
    async mangaFollow(mangaId, type, options = {}) {
        await this.agent.callAjaxAction({
            function: 'manga_follow',
            id: mangaId,
            type
        }, options);
        return true;
    }
    async mangaUnfollow(mangaId, options = {}) {
        await this.agent.callAjaxAction({
            function: 'manga_unfollow',
            id: mangaId,
            type: mangaId
        }, options);
        return true;
    }
    /**
     * Set manga view for search, featured section and e.t.c.
     * @param mode mode id: 0 - detailed, 1 - expanded list, 2 - simple list, 3 - grid
     * @param params request options
     */
    async setMangaView(mode, options = {}) {
        await this.agent.callAjaxAction({
            function: 'set_mangas_view',
            mode
        }, options);
        return true;
    }
    /**
     * Get all follow types.
     * @param options Request options
     */
    async getFollows(options = {}) {
        const result = await this.agent.callApi('follows', options);
        return Composer_1.Composer.formatTypeMapToArray(result);
    }
    /**
     * Get all follow types.
     * @param options Request options
     */
    static async getFollows(options = {}) {
        const result = await Agent_1.Agent.callApi('follows', options);
        return Composer_1.Composer.formatTypeMapToArray(result);
    }
    /**
     * Get all manga relation types.
     * @param options Request options
     */
    async getRelations(options = {}) {
        const result = await this.agent.callApi('relations', options);
        return Composer_1.Composer.formatTypeMapToArray(result);
    }
    /**
     * Get all manga relation types.
     * @param options Request options
     */
    static async getRelations(options = {}) {
        const result = await Agent_1.Agent.callApi('relations', options);
        return Composer_1.Composer.formatTypeMapToArray(result);
    }
}
exports.Mangadex = Mangadex;
Mangadex.chapter = chapter_1.ChapterResolver;
Mangadex.group = group_1.GroupResolver;
Mangadex.manga = manga_1.MangaResolver;
Mangadex.tag = tag_1.TagResolver;
Mangadex.user = user_1.UserResolver;
