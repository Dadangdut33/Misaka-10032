"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Agent = void 0;
const smol_request_1 = require("smol-request");
const fs_1 = __importDefault(require("fs"));
const cheerio_1 = __importDefault(require("cheerio"));
const multipart = __importStar(require("./lib/multipart"));
const deepmerge_1 = require("./lib/deepmerge");
const path_1 = require("path");
const error_1 = require("./lib/error");
const options_1 = require("./lib/options");
const pkg = JSON.parse(fs_1.default.readFileSync(path_1.join(__dirname, '..', 'package.json'), 'utf-8'));
class Agent {
    constructor({ host = 'https://mangadex.org', apiHost = 'https://api.mangadex.org/v2', sessionId = null, sessionExpiration = null, persistentId = null, hentai = 1, getCredentials, loginCredentials } = {}) {
        this.setSession(sessionId, sessionExpiration);
        this.setPersistent(persistentId);
        this.hentai = hentai;
        this.host = host;
        this.apiHost = apiHost;
        this.getCredentials = getCredentials || null;
        this.loginCredentials = loginCredentials || null;
    }
    setSession(id, expiration) {
        this.sessionId = id;
        this.sessionExpiration =
            expiration instanceof Date ? expiration : new Date(expiration);
    }
    setPersistent(token) {
        this.persistentId = token;
    }
    async login(username, password, rememberMe = false, options = {}) {
        this.sessionId = null;
        this.sessionExpiration = null;
        if (this.loginCredentials) {
            const session = this.loginCredentials.constructor.name === 'AsyncFunction'
                ? await this.loginCredentials()
                : this.loginCredentials.constructor.name === 'Function'
                    ? this.loginCredentials()
                    : typeof this.loginCredentials === 'object'
                        ? this.loginCredentials
                        : null;
            if (!session && typeof session === 'object') {
                throw new Error('Agent.credentials is wrong type');
            }
            if (!this.sessionId && !this.sessionExpiration) {
                if (!session.sessionId) {
                    throw new Error('No Session Id was given');
                }
                if (!session.sessionExpiration) {
                    throw new Error('No Expiration was given');
                }
                this.setSession(session.sessionId, session.sessionExpiration);
                if (session.persistentId && typeof session.persistentId === 'string') {
                    this.setPersistent(session.persistentId);
                }
            }
            const isLogin = await this.checkLogin();
            if (isLogin) {
                return true;
            }
            else {
                throw new Error('Wrong credentials was given in Agent.loginCredentials');
            }
        }
        const { sessionId, sessionExpiration, persistentId } = await Agent.login(username, password, rememberMe, {
            baseUrl: this.host,
            ...options
        });
        this.setSession(sessionId, sessionExpiration);
        if (persistentId) {
            this.setPersistent(persistentId);
        }
        return true;
    }
    static async login(username, password, rememberMe = false, options = {}) {
        if (!username || !password) {
            throw new Error('Not enough login info.');
        }
        const payload = {
            login_username: username,
            login_password: password,
            remember_me: rememberMe ? 1 : 0
        };
        const boundary = multipart.boundary();
        const { headers, data } = await smol_request_1.request(`${options.baseUrl || 'https://mangadex.org'}/ajax/actions.ajax.php?function=login`, {
            method: 'POST',
            headers: {
                'User-Agent': `mangadex-api/${pkg.version}`,
                'X-Requested-With': 'XMLHttpRequest',
                'Content-Type': `multipart/form-data boundary=${boundary}`
            }
        }, multipart.payload(boundary, payload));
        const session = {};
        const mangadexSession = headers['set-cookie'].find((cookie) => cookie.includes('mangadex_session'));
        if (mangadexSession) {
            const sessionId = mangadexSession.match(/mangadex_session=(\S+);/i)[1];
            session.sessionId = sessionId;
            const expiration = mangadexSession.match(/expires=([\S\s]+?);/i)[1];
            session.sessionExpiration = expiration;
        }
        const persistent = headers['set-cookie'].find((cookie) => cookie.includes('mangadex_rememberme_token'));
        if (persistent) {
            const persistentId = persistent.match(/mangadex_rememberme_token=(\S+);/i)[1];
            session.persistentId = persistentId;
        }
        if (!session.sessionId) {
            const errorText = cheerio_1.default.load(data)('div').text();
            if (errorText) {
                throw new Error(errorText);
            }
            throw new Error('Failed to retrieve session id.');
        }
        return session;
    }
    async logout(options = {}) {
        return Agent.logout({
            sessionId: this.sessionId,
            sessionExpiration: this.sessionExpiration,
            persistentId: this.persistentId
        }, options);
    }
    static async logout(session, options = {}) {
        let Cookie = '';
        if (session.sessionId) {
            Cookie += `mangadex_session=${session.sessionId}; `;
            if (session.persistentId) {
                Cookie += `mangadex_rememberme_token=${session.persistentId}; `;
            }
        }
        const result = await Agent.callAjaxAction({ function: 'logout' }, deepmerge_1.deepmerge(options, {
            headers: { Cookie },
            method: 'POST'
        }));
        if (result.status === 200) {
            return true;
        }
        throw new error_1.ApiError({
            code: result.status,
            message: `Unexpected status code: ${result.status}`,
            url: `ajax/actions.ajax.php?function=logout`
        });
    }
    async _onDeleteSession() {
        this.sessionId = null;
        this.sessionExpiration = null;
        this.persistentId = null;
        if (this.getCredentials) {
            const session = this.getCredentials.constructor.name === 'AsyncFunction'
                ? await this.getCredentials()
                : this.getCredentials();
            if (!this.sessionId && !this.sessionExpiration) {
                if (!session.sessionId) {
                    throw new Error('No Session Id was given');
                }
                if (!session.sessionExpiration) {
                    throw new Error('No Expiration was given');
                }
                this.setSession(session.sessionId, session.sessionExpiration);
                if (session.persistentId && typeof session.persistentId === 'string') {
                    this.setPersistent(session.persistentId);
                }
            }
            const isLogin = await this.checkLogin();
            if (isLogin) {
                return { result: 'login' };
            }
            else {
                throw new Error('Wrong credentials was given in Agent.getCredentials');
            }
        }
        try {
            await this.callAjaxAction({ function: 'logout' }, { method: 'POST' });
        }
        catch (e) { }
        return { result: 'logout' };
    }
    async loginWithSession(path) {
        const file = await fs_1.default.promises.readFile(path, 'utf8');
        const [sessionId, expiration, persistentId] = file.split('\n');
        if (!sessionId || !expiration) {
            throw new Error(`Lost "${(!sessionId && 'sessionId') || (!expiration && 'expiration')}"`);
        }
        this.setSession(sessionId, expiration);
        if (persistentId) {
            this.setPersistent(persistentId);
        }
        return this.checkLogin();
    }
    async saveSession(path) {
        return Agent.saveSession(path, {
            sessionId: this.sessionId,
            sessionExpiration: this.sessionExpiration,
            persistentId: this.persistentId
        });
    }
    static async saveSession(path, session) {
        await fs_1.default.promises.writeFile(path, `${session.sessionId}\n${session.sessionExpiration.toUTCString()}${session.persistentId ? `\n${session.persistentId}` : ''}`, 'utf8');
        return true;
    }
    setCookies(cookies) {
        const mangadexSession = cookies.find((cookie) => cookie.includes('mangadex_session'));
        if (mangadexSession) {
            const sessionId = mangadexSession.match(/mangadex_session=(\S+);/i)[1];
            const expiration = mangadexSession.match(/expires=([\S\s]+?);/i)[1];
            if (sessionId === 'deleted') {
                return this._onDeleteSession();
            }
            else {
                this.setSession(sessionId, expiration);
            }
            return true;
        }
        else {
            return false;
        }
    }
    getCookie() {
        const cookies = [];
        if (this.sessionId) {
            cookies.push(`mangadex_session=${this.sessionId}`);
            if (this.persistentId) {
                cookies.push(`mangadex_rememberme_token=${this.persistentId}`);
            }
            cookies.push(`mangadex_h_toggle=${this.hentai}`);
        }
        return cookies.join('; ');
    }
    async checkLogin() {
        const result = await this.callApi('user/me');
        return Boolean(result);
    }
    async call(url, options = {}, body) {
        const Cookie = this.getCookie();
        const { data, headers } = await Agent.call(url, deepmerge_1.deepmerge({
            baseUrl: this.host,
            headers: {
                Cookie
            }
        }, options), body);
        const resetCookies = this.setCookies(headers['set-cookie']);
        if (typeof resetCookies === 'boolean') {
            return data;
        }
        else {
            const { result } = await resetCookies;
            if (result === 'login') {
                return this.call(url, options);
            }
            else {
                throw new Error(`Authorization required\n${url}`);
            }
        }
    }
    static async call(url, options = {}, body) {
        const requestUrl = `${options.baseUrl || options_1.DefaultOptions.host}${!(url.startsWith('/') && options.baseUrl.endsWith('/')) && '/'}${url}`;
        const result = await smol_request_1.request(requestUrl, deepmerge_1.deepmerge({
            method: 'GET',
            headers: {
                'User-Agent': `mangadex-api/${pkg.version}`,
                ...(body
                    ? {
                        'Content-Type': 'application/json'
                    }
                    : {})
            }
        }, options), body ? JSON.stringify(body) : undefined);
        return result;
    }
    async callApi(url, options = {}, body) {
        const response = await this.call(url, deepmerge_1.deepmerge(options, {
            baseUrl: this.apiHost,
            responseType: 'json'
        }), body);
        if (response.status === 'error') {
            throw new error_1.ApiError({
                message: response.message,
                code: response.code,
                url
            });
        }
        return response.data;
    }
    static async callApi(url, options = {}, body) {
        const { data: response } = await Agent.call(url, deepmerge_1.deepmerge({
            baseUrl: options_1.DefaultOptions.apiHost
        }, options, {
            responseType: 'json'
        }), body);
        if (response.status === 'error') {
            throw new error_1.ApiError({
                message: response.message,
                code: response.code,
                url
            });
        }
        return response.data;
    }
    async callAjaxAction(params, options = {}, body) {
        const result = await this.call('ajax/actions.ajax.php', deepmerge_1.deepmerge(options, {
            params
        }), body);
        return result;
    }
    static async callAjaxAction(params, options = {}, body) {
        const result = await Agent.call('ajax/actions.ajax.php', deepmerge_1.deepmerge(options, {
            params
        }), body);
        return result;
    }
}
exports.Agent = Agent;
